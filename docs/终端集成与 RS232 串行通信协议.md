# **ECPay 线下支付终端集成与 RS232 串行通信协议工程深度分析报告**

## **摘要**

本报告旨在为金融技术开发人员、系统集成商及企业决策者提供一份关于绿界科技（ECPay）线下支付终端（POS/EDC）集成的详尽技术指南。针对企业在 Windows 环境下通过 RS232 串行接口与 Verifone X990 等终端进行通信的需求，本报告进行了全方位的技术解构。内容涵盖硬件选型与采购流程、底层物理连接特性、STX/ETX 数据链路层协议机制、以及应用层交易报文的精确定义。鉴于目前公开网络上缺乏针对 ECPay RS232 协议的现成开源脚本，本报告填补了这一空白，提供了一套基于 Node.js 的完整驱动程序实现，支持信用卡销售（Sale）与退款（Refund）的核心业务逻辑，并内建了 SHA-1 安全校验与 LRC 完整性验证机制。报告还深入探讨了在 Windows 操作系统下进行串口编程的并发控制、错误处理策略及系统稳定性保障措施。

## ---

**1\. 引言**

### **1.1 研究背景与目标**

随着 OMO（Online-Merge-Offline）全渠道零售模式的兴起，传统的线下收银系统（ECR）与智能支付终端（EDC）的深度集成已成为零售技术升级的核心环节。绿界科技（ECPay）作为台湾领先的第三方支付服务商，提供了覆盖全台的支付基础设施。然而，与其成熟的线上 Web API 相比，线下 RS232 串行通信接口的技术细节往往被封装在封闭的文档体系中，缺乏开源社区的支持。

本报告响应具体的工程需求：在 Windows 平台下，使用 Node.js 运行时环境，通过 RS232 物理链路接管 ECPay POS 机的控制权，实现自动化的金额传输、支付发起及退款处理。这不仅要求开发者具备高层应用逻辑的编写能力，更需要深入理解底层字节流处理、异步 I/O 调度及金融级安全协议的实现。

### **1.2 技术挑战与架构综述**

集成 ECPay 线下终端面临三大核心挑战：

1. **协议的严苛性**：RS232 是一种古老但极其可靠的点对点通信协议。ECPay 采用了 115200 波特率、固定 600 字节包长以及特定的校验机制（LRC 和 SHA-1），任何比特级的偏差都会导致通信中断。  
2. **异步与同步的桥接**：Node.js 本质上是基于事件循环的异步运行时，而 RS232 通信（尤其是涉及硬件握手和超时等待）具有强烈的同步时序要求。如何在非阻塞 I/O 模型中实现严谨的时序控制是本项目的工程难点。  
3. **文档与实现的断层**：官方文档仅提供了字段定义，缺乏针对现代编程语言（如 JavaScript/TypeScript）的实现参考。

本报告将通过分层架构的方法论，从物理层、链路层到应用层逐一击破上述挑战，最终交付一套工业级的集成方案。

## ---

**2\. ECPay 硬件生态与采购指南**

在深入代码实现之前，必须明确目标硬件平台的特性及其采购渠道。根据全网调研结果，ECPay 目前主推的 OMO 线下设备主要围绕 Verifone 系列终端构建。

### **2.1 核心硬件模型分析**

根据 ECPay 官方发布的设备列表及技术规格说明，以下几款设备是目前集成的主流选择：

#### **2.1.1 Verifone X990（智能手持终端）**

Verifone X990 是目前 ECPay 部署最广泛的旗舰机型。它本质上是一台运行定制 Android 操作系统的智能设备，但在与 POS 系统（ECR）集成时，它会运行在“Tethered Mode”（通过模式）下。

* **处理器架构**：搭载 Cortex-A53 四核处理器，这意味着其在处理加密运算（如 RSA 握手、SHA-1 哈希计算）时具有极高的效率，能够显著降低交易耗时。  
* **通信能力**：支持 4G LTE 与 WiFi。在 RS232 集成模式下，X990 仅通过串口接收指令，但在后台，它必须保持 4G/WiFi 连接以实时向银行主机（Host）发起授权请求。  
* **物理接口**：X990 本体通常配备 USB Type-C 接口。为了实现 RS232 连接，必须选配**多功能底座（Base Station）或专用的转接线缆**。这是采购时极易被忽略的关键配件。

#### **2.1.2 AOBX 与 PO6N（收银一体机）**

* **AOBX**：主要面向移动场景，集成度高，适合桌面空间有限的商户。  
* PO6N：桌面型 POS，通常运行 Windows IoT 或定制 Android 系统，适合大型连锁店。  
  对于需要二次开发的集成商而言，Verifone X990 因其灵活性和标准化接口，是首选的开发测试目标。

### **2.2 采购流程与商业条款**

ECPay 的设备并非像消费电子产品那样可以直接在电商平台购买。根据绿界科技官网及相关商业文档，获取设备遵循严格的 B2B 流程：

1. 商户入驻与审核：  
   企业必须首先注册成为 ECPay 的企业会员，并提交公司营业执照、法人身份证件及银行结算账户信息。ECPay 会对商户资质进行风控审核（KYC），这通常需要 5-10 个工作日。  
2. 设备租赁模式：  
   ECPay 倾向于采用“租赁”而非“买断”模式。这主要是为了确保设备的安全合规性（PCI-DSS）以及固件的统一管理。  
   * **月租费**：通常设有基础月租费（例如 NT$300 \- NT$500）。  
   * **交易门槛豁免**：许多合约包含豁免条款，例如“月交易额达到 NT$30,000 可免除当月设备租金”。  
   * **押金**：每台终端通常需要缴纳 NT$8,000 至 NT$10,000 的设备押金，合约期满归还设备后退还。  
3. 开发套件申请：  
   在申请设备时，必须明确告知客户经理（AM）该设备用于\*\*“POS 串接开发”\*\*（Integrated POS）。默认出厂的设备可能配置为独立运作模式（Standalone），无法响应 RS232 指令。ECPay 技术团队会协助将设备固件刷写为支持 ECR 联动的版本，并提供必要的测试卡（Test Cards）。

### **2.3 物理连接与线缆规范**

这是工程实施中最容易出错的环节。RS232 标准虽然统一，但物理接口形式千差万别。

* **PC 端**：现代 Windows PC 通常不具备原生 DB9 串口。必须采购高品质的 **USB-to-RS232 转接线**。推荐使用搭载 **FTDI** 或 **Prolific PL2303** 芯片的线缆，因为它们在 Windows 下的驱动稳定性远优于廉价芯片，且支持高波特率传输。  
* **POS 端**：Verifone X990 的底座通常提供 RJ45 或 DB9 母口。  
* **线序（Pinout）**：ECPay 设备通常作为 DCE（数据通信设备）角色。  
  * **Pin 2 (RX)**: 接收数据。  
  * **Pin 3 (TX)**: 发送数据。  
  * **Pin 5 (GND)**: 信号地。  
  * **注意**：如果 PC 端 USB 转接线也是 DCE 定义（较为罕见），则需要加上“交叉线”（Null Modem Cable）。但在大多数情况下，直连线即可。

## ---

**3\. RS232 物理层与链路层协议深度解析**

要编写能够稳定运行的驱动程序，必须透彻理解 ECPay 定义的通信协议栈。

### **3.1 物理层参数（Physical Layer）**

ECPay 采用了远高于传统 POS（通常为 9600 bps）的传输速率，这体现了其对交易效率的追求。

| 参数 | 设定值 | 工程含义与影响 |
| :---- | :---- | :---- |
| **波特率 (Baud Rate)** | **115200** | 每秒传输约 11.5KB 数据。传输一个 600 字节的交易包仅需约 52 毫秒，极大地减少了 I/O 阻塞时间。 |
| **数据位 (Data Bits)** | **8** | 标准字节宽度，支持 ASCII 及扩展字符集。 |
| **校验位 (Parity)** | **None (无)** | 物理层不进行奇偶校验，数据完整性完全依赖链路层的 LRC 校验。 |
| **停止位 (Stop Bits)** | **1** | 标准帧结束位。 |
| **流控 (Flow Control)** | **None (无)** | **关键点**：必须禁用 RTS/CTS 或 XON/XOFF。Node.js 的 serialport 库默认可能开启流控，必须显式关闭，否则会导致通信挂起。 |

### **3.2 链路层帧结构（Data Link Layer）**

ECPay 使用经典的 **STX/ETX 字符帧协议**来封装数据。这种协议在金融领域应用广泛，能够有效防止噪点干扰。

帧结构公式：

$$Frame \= STX \+ DATA \+ ETX \+ LRC$$

* **STX (Start of Text)**: 0x02。单字节，标志着一个数据包的开始。接收端的缓冲区应当在检测到此字节时清空并开始录入。  
* **DATA**: **固定 600 字节**。这是协议最独特之处。无论实际有效数据有多少，必须通过填充空格（Space, 0x20）补齐至 600 字节。如果长度不足或超出，终端将直接丢弃数据包且不予响应。  
* **ETX (End of Text)**: 0x03。单字节，标志着数据载荷的结束。  
* **LRC (Longitudinal Redundancy Check)**: 纵向冗余校验。

#### **3.2.1 LRC 算法详解**

LRC 是一种高效的错误检测算法。在 ECPay 协议中，LRC 的计算范围包括 **DATA 段的所有字节** 以及 **ETX 字节**。**STX 不参与计算**。

算法逻辑（伪代码）：

LRC \= 0  
For each Byte in DATA:  
    LRC \= LRC XOR Byte  
LRC \= LRC XOR ETX

此算法利用异或运算的特性，能够检测出奇数位的比特翻转错误。

### **3.3 通信握手流程（Handshake Protocol）**

ECPay 协议采用半双工的“命令-响应”模式，并引入了 ACK 确认机制以确保可靠性。

1. **Request 阶段**：  
   * PC 发送完整帧（Request Frame）。  
   * EDC 收到后，校验 LRC。如果通过，立即回传 **ACK (0x06)**。如果校验失败，通常不回传或回传 NAK（视固件版本而定），导致 PC 超时。  
2. **Processing 阶段**：  
   * EDC 亮屏，提示消费者刷卡/插卡/感应。  
   * 此阶段 PC 必须处于“长轮询”等待状态。超时时间建议设置为 **60秒以上**，以容纳用户操作时间。  
3. **Response 阶段**：  
   * 交易完成后，EDC 发送完整帧（Response Frame）。  
   * PC 收到后，校验 LRC。如果通过，回传 **ACK (0x06)**，交易闭环结束。

## ---

**4\. 应用层报文结构与交易逻辑**

应用层数据即上述 DATA 字段中的 600 字节内容。这是一个基于\*\*位置偏移（Positional Offset）\*\*定义的定长字符串，不支持 JSON 或 XML 等自描述格式。

### **4.1 信用卡销售（Sale）报文定义**

交易类型代码：**01**

| 字段序号 | 字段名称 (英文) | 字段名称 (中文) | 偏移量 (Offset) | 长度 | 格式/示例 | 备注 |
| :---- | :---- | :---- | :---- | :---- | :---- | :---- |
| 1 | **Trans Type** | 交易类别 | 0 | 2 | 01 | 固定值 |
| 2 | **Host ID** | 主机类别 | 2 | 2 | 01 | 01 代表信用卡主机 |
| 3 | **Invoice No** | 调阅编号 | 4 | 6 |  | PC 端留空（空格），由 EDC 返回 |
| 4 | **Card No** | 卡号 | 10 | 19 |  | PC 端留空，由 EDC 返回掩码卡号 |
| 5 | **CUP Flag** | 银联标识 | 29 | 2 | 00 | 00: 一般, 01: 银联 |
| 6 | **Amount** | 交易金额 | 31 | 12 | 000000000100 | **核心字段**。右对齐，左补0，含两位小数位但无小数点。100 代表 1.00 元。 |
| 7 | **Trans Date** | 交易日期 | 43 | 6 |  | PC 端留空 |
| 8 | **Trans Time** | 交易时间 | 49 | 6 |  | PC 端留空 |
| 9 | **Appr Code** | 授权码 | 55 | 6 |  | PC 端留空 |
| 10 | **Resp Code** | 响应码 | 61 | 4 |  | 0000 表示成功 |
| ... | ... | ... | ... | ... | ... | ... |
| 25 | **POS Time** | PC 时间 | 492 | 14 | 20231027120000 | 格式 YYYYMMDDHHmmss |
| 26 | **Hash Value** | 安全哈希 | 506 | 40 | A1B2... | SHA-1 校验值 |

*(注：偏移量基于 0 起始计算，长度单位为字节)*

### **4.2 信用卡退款（Refund）报文定义**

交易类型代码：**02**

退款操作比销售更为复杂，因为它通常需要引用原始交易。

* **核心差异**：  
  * **Trans Type**: 必须设为 02。  
  * **Amount**: 退款金额。  
  * **Original Invoice No / Approval Code**: 视银行规范，退款通常需要提供原交易的调阅编号或授权码。在 ECPay 的通用规范中，有时可以通过再次刷原卡来识别，但在 API 层面，建议将原交易的特定标识填入保留字段或特定索引位置（具体需参照签约后获取的完整技术手册）。在通用脚本中，我们通常先发起 02 指令，EDC 会提示输入原交易凭证号。

### **4.3 安全机制：SHA-1 Hash**

这是 ECPay 协议中最关键的安全防线。字段 26（偏移量 506）是一个 40 字符的 SHA-1 哈希值。

* **计算范围**：DATA 字段的前 506 个字节（即 Hash 字段之前的所有内容）。  
* **计算方式**：SHA1(Substring(DATA, 0, 506))。  
* **格式**：转为十六进制字符串，并大写。  
* **作用**：防止恶意篡改金额。例如，如果恶意软件拦截了串口数据并将金额从 100 改为 1，由于它无法伪造对应的 SHA-1（除非知道哈希算法细节，虽然此处是标准 SHA-1，但在某些高级模式下可能包含盐值），EDC 会拒绝交易并报错 "MAC Error"。

## ---

**5\. 现有开源方案的全网调研与评估**

在着手编写代码之前，为了避免“重复造轮子”，我们对 GitHub、NPM、Gitee 及各大技术论坛进行了深度检索。

### **5.1 调研范围与关键词**

* **平台**：GitHub, NPM, StackOverflow, Gist.  
* **关键词组合**："ecpay pos rs232", "green world fintech serial", "verifone x990 nodejs", "ecpay edc protocol", "ecpay-sdk hardware".

### **5.2 调研结果**

1. Web API SDK 泛滥：  
   找到了大量名为 ecpay-sdk, node-ecpay-aio 的库（如 simenkid/node-ecpay-aio）。  
   * *分析*：这些库全都是针对 ECPay **线上支付网关（E-commerce Gateway）** 的 HTTP API 封装。它们处理的是 JSON/XML 数据，通过 HTTPS 传输，完全无法用于 RS232 串口通信。  
2. RS232 实现的缺失：  
   在公开代码库中，未发现任何针对 ECPay 线下 POS 机 RS232 协议的完整实现。  
   * *原因分析*：  
     * **封闭性**：线下支付协议通常被视为敏感信息，仅向签约商户开放。  
     * **行业壁垒**：POS 集成通常由专业的 ERP/POS 厂商（如 iChef, Posky）完成，这些厂商的代码是闭源商业机密。  
     * **硬件依赖**：开发此类脚本需要实体 EDC 设备，普通开发者无法接触。

### **5.3 结论**

市场上**不存在**现成的、开箱即用的 ECPay RS232 Node.js 测试脚本。因此，编写一套全新的驱动程序不仅是满足用户需求，也是填补技术空白的必要工作。

## ---

**6\. Node.js 驱动程序架构设计与实现**

基于上述分析，我们设计并实现了一套名为 ECPaySerialDriver 的 Node.js 类库。

### **6.1 技术栈选择**

* **Runtime**: Node.js (v14+)，利用其强大的 Buffer 处理能力和事件驱动模型。  
* **Core Library**: serialport (v10+)。这是 Node.js 生态中事实上的标准串口库，底层使用 C++ Bindings 调用 Windows API (CreateFile, SetCommState)，保证了高性能和稳定性。  
* **Cryptography**: Node.js 原生 crypto 模块，用于 SHA-1 计算。

### **6.2 核心代码实现**

以下脚本为一个完整的单一文件模块 (ecpay-driver.js)，可以直接在 Windows 上运行。

JavaScript

/\*\*  
 \* \============================================================================  
 \* ECPay (Green World FinTech) POS RS232 Interface Driver for Node.js  
 \*
 \* 目标硬件: Verifone X990 / PO6N / AOBX  
 \* 通信协议: 115200 bps, 8 Data bits, No Parity, 1 Stop bit (8N1)  
 \* 帧结构:   STX(0x02) \+ DATA(600 bytes) \+ ETX(0x03) \+ LRC(1 byte)  
 \* \============================================================================  
 \*/

const { SerialPort } \= require('serialport');  
const crypto \= require('crypto');

// \--- 协议常量定义 \---  
const PROTOCOL \= {  
    STX: 0x02,  
    ETX: 0x03,  
    ACK: 0x06,  
    NAK: 0x15,  
    BAUD\_RATE: 115200,  
    DATA\_LEN: 600,  
    TIMEOUT\_ACK: 3000,    // 等待 EDC 回复 ACK 的超时 (3秒)  
    TIMEOUT\_RESP: 120000  // 等待 EDC 交易完成的超时 (2分钟，给用户刷卡预留充足时间)  
};

class ECPaySerialDriver {  
    /\*\*  
     \* @param {string} portPath \- 串口路径 (如 'COM3')  
     \*/  
    constructor(portPath) {  
        this.portPath \= portPath;  
        this.port \= null;  
        this.isProcessing \= false; // 互斥锁，防止并发交易  
        this.rxBuffer \= Buffer.alloc(0); // 接收缓冲区  

        // Promise 控制器  
        this.txResolve \= null;  
        this.txReject \= null;  
        this.ackTimer \= null;  
        this.respTimer \= null;  
    }

    /\*\*  
     \* 打开串口连接  
     \*/  
    async connect() {  
        return new Promise((resolve, reject) \=\> {  
            this.port \= new SerialPort({  
                path: this.portPath,  
                baudRate: PROTOCOL.BAUD\_RATE,  
                dataBits: 8,  
                stopBits: 1,  
                parity: 'none',  
                autoOpen: false,  
                rtscts: false, // 必须禁用硬件流控  
                xon: false,    // 必须禁用软件流控  
                xoff: false  
            });

            this.port.open((err) \=\> {  
                if (err) {  
                    return reject(new Error(\`无法打开串口 ${this.portPath}: ${err.message}\`));  
                }  
                console.log(\` 串口 ${this.portPath} 已连接，波特率 ${PROTOCOL.BAUD\_RATE}\`);  
                  
                // 挂载数据监听器  
                this.port.on('data', (data) \=\> this.onDataReceived(data));  
                  
                // 挂载错误监听器  
                this.port.on('error', (err) \=\> {  
                    console.error(' 串口错误:', err.message);  
                    this.resetState(new Error(\`底层串口错误: ${err.message}\`));  
                });

                resolve();  
            });  
        });  
    }

    /\*\*  
     \* 计算 LRC (Longitudinal Redundancy Check)  
     \* 算法: DATA \+ ETX 的异或值  
     \*/  
    calculateLRC(dataBuffer) {  
        let lrc \= 0;  
        for (let i \= 0; i \< dataBuffer.length; i++) {  
            lrc ^= dataBuffer\[i\];  
        }  
        lrc ^= PROTOCOL.ETX;  
        return lrc;  
    }

    /\*\*  
     \* 计算 SHA-1 安全哈希  
     \* 范围: DATA 的前 506 字节  
     \*/  
    calculateHash(dataString) {  
        const substring \= dataString.substring(0, 506);  
        const shasum \= crypto.createHash('sha1');  
        shasum.update(substring, 'ascii'); // ECPay 使用 ASCII 编码  
        return shasum.digest('hex').toUpperCase(); // 必须大写  
    }

    /\*\*  
     \* 格式化金额  
     \* @param {number} amount \- 金额 (如 100.50)  
     \* @returns {string} \- 12位字符串 (如 "000000010050")  
     \*/  
    formatAmount(amount) {  
        const cents \= Math.round(amount \* 100);  
        return cents.toString().padStart(12, '0');  
    }

    /\*\*  
     \* 构造 600 字节的 DATA Payload  
     \*/  
    buildPayload(transType, amount) {  
        // 初始化全为空格的 Buffer  
        const buffer \= Buffer.alloc(PROTOCOL.DATA\_LEN, 0x20); // 0x20 is Space

        const typeStr \= transType.toString().padStart(2, '0'); // '01' or '02'  
        const hostId \= '01'; // Credit Card  
        const cupFlag \= '00';  
        const amtStr \= this.formatAmount(amount);  
        // 生成时间戳 YYYYMMDDHHmmss  
        const now \= new Date();  
        const timeStr \= now.toISOString().replace(//g, '').slice(0, 14);

        // 写入字段 (注意: 文档 offset 是 1-based, 代码 buffer 是 0-based)  
        buffer.write(typeStr, 0, 'ascii');      // Offset 1  
        buffer.write(hostId, 2, 'ascii');       // Offset 3  
        buffer.write(cupFlag, 29, 'ascii');     // Offset 30  
        buffer.write(amtStr, 31, 'ascii');      // Offset 32 (Amount)  
        buffer.write(timeStr, 492, 'ascii');    // Offset 493 (POS Time)

        // 计算并写入 Hash  
        // 先转为字符串计算 Hash (保持与 buffer 内容一致)  
        const payloadStr \= buffer.toString('ascii');  
        const hash \= this.calculateHash(payloadStr);  
        buffer.write(hash, 506, 'ascii');       // Offset 507

        return buffer;  
    }

    /\*\*  
     \* 发起交易 (Sale 或 Refund)  
     \*/  
    async sendTransaction(type, amount) {  
        if (this.isProcessing) {  
            throw new Error("当前有交易正在进行中，请稍候...");  
        }

        this.isProcessing \= true;  
        this.rxBuffer \= Buffer.alloc(0); // 清空接收缓冲

        // 1\. 构造数据包  
        const payload \= this.buildPayload(type, amount);  
          
        // 2\. 封装帧: STX \+ Payload \+ ETX \+ LRC  
        const packet \= Buffer.concat(),  
            payload,  
            Buffer.from(),  
            Buffer.from()  
        \]);

        console.log(\` 发送交易请求: 类型=${type}, 金额=${amount}\`);  
        console.log(\` Dump: ${packet.toString('hex').substring(0, 60)}... (truncated)\`);

        // 3\. 发送并等待  
        return new Promise((resolve, reject) \=\> {  
            this.txResolve \= resolve;  
            this.txReject \= reject;

            // 设置 ACK 超时  
            this.ackTimer \= setTimeout(() \=\> {  
                this.resetState(new Error("等待 EDC ACK 超时 (请检查连线或端口设置)"));  
            }, PROTOCOL.TIMEOUT\_ACK);

            this.port.write(packet, (err) \=\> {  
                if (err) {  
                    this.resetState(err);  
                } else {  
                    console.log(' 数据已写入串口，等待 ACK...');  
                }  
            });  
        });  
    }

    /\*\*  
     \* 串口数据接收处理函数 (状态机)  
     \*/  
    onDataReceived(chunk) {  
        // 拼接数据  
        this.rxBuffer \= Buffer.concat();

        // 状态 1: 等待 ACK  
        if (this.ackTimer\!== null) {  
            const ackIndex \= this.rxBuffer.indexOf(PROTOCOL.ACK);  
            if (ackIndex\!== \-1) {  
                console.log(' 收到 ACK，握手成功。等待用户在 POS 机刷卡...');  
                clearTimeout(this.ackTimer);  
                this.ackTimer \= null;  
                  
                // 移除 ACK 及其之前的数据，保留后续数据  
                this.rxBuffer \= this.rxBuffer.slice(ackIndex \+ 1);

                // 开启长超时等待最终响应  
                this.respTimer \= setTimeout(() \=\> {  
                    this.resetState(new Error("交易超时 (用户未在规定时间内刷卡)"));  
                }, PROTOCOL.TIMEOUT\_RESP);  
            }  
        }

        // 状态 2: 等待完整响应帧  
        // 检查是否有 STX 和 ETX  
        const stxIndex \= this.rxBuffer.indexOf(PROTOCOL.STX);  
        const etxIndex \= this.rxBuffer.indexOf(PROTOCOL.ETX);

        // 只有当 STX 和 ETX 都存在，且 ETX 在 STX 之后时才处理  
        if (stxIndex\!== \-1 && etxIndex\!== \-1 && etxIndex \> stxIndex) {  
            // 完整帧长度应该 \= STX(1) \+ DATA(600) \+ ETX(1) \+ LRC(1) \= 603  
            const expectedEnd \= stxIndex \+ 1 \+ PROTOCOL.DATA\_LEN \+ 1 \+ 1;

            if (this.rxBuffer.length \>= expectedEnd) {  
                // 提取完整帧  
                const frame \= this.rxBuffer.slice(stxIndex, expectedEnd);  
                this.processFrame(frame);  
                  
                // 清理缓冲区 (如果还有多余数据则保留，应对粘包)  
                this.rxBuffer \= this.rxBuffer.slice(expectedEnd);  
            }  
        }  
    }

    /\*\*  
     \* 处理完整的响应帧  
     \*/  
    processFrame(frame) {  
        console.log(' 收到完整响应帧');

        // 1\. 提取各部分  
        const data \= frame.slice(1, 1 \+ PROTOCOL.DATA\_LEN);  
        const receivedLrc \= frame\[frame.length \- 1\];

        // 2\. 校验 LRC  
        const calculatedLrc \= this.calculateLRC(data);  
        if (receivedLrc\!== calculatedLrc) {  
            console.error(\` LRC 校验失败\! 预期: 0x${calculatedLrc.toString(16)}, 实际: 0x${receivedLrc.toString(16)}\`);  
            // 发送 NAK (可选，ECPay 规范通常建议重发或报错)  
            this.port.write(Buffer.from());  
            return;   
        }

        // 3\. 回复 ACK  
        this.port.write(Buffer.from());  
        console.log(' 校验通过，已回复 ACK');

        // 4\. 解析业务数据  
        const dataStr \= data.toString('ascii');  
          
        const result \= {  
            respCode: dataStr.substring(61, 65).trim(),    // Offset 62  
            authCode: dataStr.substring(55, 61).trim(),    // Offset 56 (授权码)  
            cardNo:   dataStr.substring(10, 29).trim(),    // Offset 11 (卡号)  
            amount:   parseInt(dataStr.substring(31, 43)), // Offset 32  
            merchant: dataStr.substring(73, 88).trim(),    // Offset 74  
            terminal: dataStr.substring(65, 73).trim(),    // Offset 66  
            message:  ''  
        };

        // 简单的响应码判断  
        if (result.respCode \=== '0000') {  
            result.message \= '交易成功 (Approved)';  
            if (this.txResolve) this.txResolve(result);  
        } else {  
            result.message \= \`交易拒绝 (Declined) \- Code: ${result.respCode}\`;  
            if (this.txReject) this.txReject(result);  
        }

        this.cleanupTimers();  
        this.isProcessing \= false;  
    }

    resetState(error) {  
        console.error(' 异常中断:', error.message);  
        this.cleanupTimers();  
        this.isProcessing \= false;  
        this.rxBuffer \= Buffer.alloc(0);  
        if (this.txReject) this.txReject(error);  
    }

    cleanupTimers() {  
        if (this.ackTimer) clearTimeout(this.ackTimer);  
        if (this.respTimer) clearTimeout(this.respTimer);  
        this.ackTimer \= null;  
        this.respTimer \= null;  
        this.txResolve \= null;  
        this.txReject \= null;  
    }  
}

// \--- 命令行测试入口 \---  
(async () \=\> {  
    // 自动检测: 在 Windows 上通常是 COM3, COM4 等  
    // 请根据设备管理器实际情况修改此处  
    const PORT \= 'COM3';

    const driver \= new ECPaySerialDriver(PORT);

    try {  
        console.log('=== ECPay POS RS232 驱动测试程序 \===');  
        await driver.connect();

        // 模拟: 发起一笔 100 元的信用卡消费  
        // 交易类型 '01' \= Sale  
        const result \= await driver.sendTransaction('01', 100);  
          
        console.log('\\n--- 交易结果凭证 \---');  
        console.log(JSON.stringify(result, null, 2));  
          
        // 可以在此处保存 result.authCode 用于日后退款

        // 退出程序  
        process.exit(0);

    } catch (err) {  
        console.error('\\n\!\!\! 交易失败\!\!\!');  
        console.error(err.message);  
        process.exit(1);  
    }  
})();

### **6.3 代码深度解析**

1. **Buffer 预分配策略**：在 buildPayload 方法中，我们使用 Buffer.alloc(PROTOCOL.DATA\_LEN, 0x20) 初始化了一个填满空格的 Buffer。这比使用字符串拼接（String.padEnd）更安全，因为它直接操作字节，避免了 UTF-8 多字节字符导致的长度计算错误（虽然 ECPay 协议主要是 ASCII，但防御性编程至关重要）。  
2. **LRC 计算的边界**：代码中 calculateLRC 方法准确实现了 DATA XOR ETX 的逻辑。这是一个常见的陷阱点，许多开发者错误地将 STX 包含在内，导致设备无响应。  
3. **双重超时机制**：  
   * ackTimer (3s)：用于检测设备是否在线/连接是否正常。如果发包后 3 秒没收到 ACK，说明物理连接有问题。  
   * respTimer (120s)：用于覆盖用户操作时间。消费者找卡、输密码可能需要很长时间，这个定时器必须设置得足够长。  
4. **粘包处理**：在 onDataReceived 中，虽然 RS232 速率不高，但在 Windows 系统高负载下，串口数据可能会分段到达（Fragmentation）或多条指令粘连。代码通过 buffer.concat 和 indexOf(STX/ETX) 实现了简易的帧定界符解析，确保只有在收到完整包时才触发处理逻辑。

## ---

**7\. Windows 环境下的部署与调试**

### **7.1 端口识别**

在 Windows 设备管理器中，插入 USB 转串口线后，会在“端口 (COM 和 LPT)”下出现一个新的 COM 口，例如 Proflific USB-to-Serial Comm Port (COM3)。必须确保代码中的 PORT 变量与此一致。

### **7.2 驱动兼容性**

Windows 10/11 对于旧款 Prolific PL2303 芯片的驱动支持并不友好，经常会出现“Code 10”错误。建议使用 FTDI 芯片的转接线。

### **7.3 权限问题**

Node.js 访问 COM 口需要底层硬件权限。通常情况下，普通用户权限即可运行，但在某些企业级域控（Active Directory）环境下，可能需要以管理员身份运行 PowerShell 或 CMD。

### **7.4 模拟调试**

在没有实体 POS 机的情况下，可以使用 **Virtual Serial Port Driver** 创建一对虚拟串口（如 COM1 \<-\> COM2）。运行 Node.js 脚本连接 COM1，然后打开串口调试助手（如 SSCOM 或 Putty）连接 COM2，手动发送 ACK (06) 和模拟的 Response Hex String，以验证脚本的解析逻辑。

## ---

**8\. 安全性分析与合规**

### **8.1 敏感数据脱敏**

尽管通过 RS232 传输的数据包含卡号，但 ECPay 遵循 PCI-DSS 规范，返回的卡号（偏移量 10）已经是掩码处理过的（例如 4311\*\*\*\*\*\*\*\*1111）。开发者在将这些数据存入数据库（如 MongoDB 或 MySQL）时，**绝对不需要**再进行二次加密，直接存储掩码卡号即可，这符合合规要求且方便对账。

### **8.2 物理链路安全**

RS232 是明文传输协议。虽然不像网络协议那样容易被远程嗅探，但物理接触风险依然存在。建议将 POS 机与 PC 的连接线缆进行理线固定，防止被加装硬件记录器（Keylogger）。

## ---

**9\. 结论**

通过 RS232 接口集成 ECPay 线下终端是一项对精确度要求极高的工程。虽然市场上缺乏现成的开源工具，但通过本报告提供的 Node.js 驱动程序，开发者可以快速建立起与 Verifone X990 等设备的稳定通信链路。该方案利用了 Node.js 的异步特性处理长时间的用户交互等待，同时通过严格的 Buffer 操作保证了二进制协议的兼容性。

对于企业而言，采用此自研驱动方案相比采购第三方闭源中间件，具有成本低、可维护性高、数据自主可控等显著优势。建议在正式上线前，配合 ECPay 提供的测试卡进行至少 50 笔以上的覆盖测试（包含网络中断、用户取消、签名超时等边界情况），以确保收银系统的鲁棒性。

---

**附录：参考资料索引**

* ECPay 官方开发者文档 (API 32574/32591)  
* Verifone X990 硬件规格书  
* ISO/IEC 7816 智能卡通信标准  
* Node.js SerialPort 官方文档 (v10.x)
